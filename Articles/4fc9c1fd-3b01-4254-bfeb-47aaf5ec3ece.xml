<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="0" Content_Hash="0">
  <Metadata>
    <Id>4fc9c1fd-3b01-4254-bfeb-47aaf5ec3ece</Id>
    <Library_Id>be5273b1-d682-4361-99d9-6204f2d47eb7</Library_Id>
    <Title>Luring Vulnerability</Title>
    <Category />
    <Phase />
    <Technology />
    <Type />
    <DirectLink>Luring Vulnerability</DirectLink>
    <Author />
    <Priority />
    <Status />
  </Metadata>
  <Content Sanitized="false" DataType="wikitext">
    <Data><![CDATA[=Description=

The traditional way of building applications so that they run with the current user privileges has helped increase the impact of some attacks. Attacks such as the&nbsp;API Hijacking Attack and other attacks that result in escalation of privilege have stemed from the fact that the called module usually assumes the authority of its caller.

Java and the .NET Framework provide Code Access Security mechanisms that allow enforcement of security based on code identity instead of on the user executing the code. These mechanisms allow developers to write and package code in a fashion that controls the security aspect of their invocation and execution. Using this, a developer can state the minimum security requirements that a calling module must meet before it can execute the protected module. One of the main advantages that this mechanism offers is the fact that mobile code (code downloaded from the internet) will not be able to execute protected modules that already exist on the local machine.

In a luring attack, the attacker 'lures' an application component with higher privileges than the attacker's code to do something on its behalf. This happens when a snippet of code with restricted security privileges calls a component with higher privileges into executing restricted operations. Such behavior is usually the result of lack of or insufficient permission checks on the caller of the privileged component. Luring Attacks can also be a result of a privileged library calling malicious code from an untrusted library.

Calling unmanaged modules from protected managed modules.</strong> This can result in escalation of privilege as the calling module may not be able to verify the authenticity of the unmanaged module.

Failure to check the authority of the calling module. </strong>Depending upon the security options selected, the called module may check:

No caller permissions - if no permissions are checked, then this could be used in a luring attack. 

Permissions granted to the immediate caller of the module - if the module is capable of performing dangerous actions on the machine, an attacker may call another module, which in turn may call the protected module in order to launch a luring attack

The permissions granted to every caller in the call-stack - in this case, luring attacks will be prevented.

=Impact=

Elevation of privilege

=Countermeasures=

When creating packages or assemblies that could be loaded by malicious code, use platform-supplied techniques to explicitly define the security restrictions of your module.

Use LinkDemand or StackWalk techniques in both frameworks to check the permissions on any calling module.

=Application Check=

]]></Data>
  </Content>
</TeamMentor_Article>