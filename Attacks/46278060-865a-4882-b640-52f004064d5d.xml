<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="1416557092" Content_Hash="-895121066">
  <Metadata>
    <Id>46278060-865a-4882-b640-52f004064d5d</Id>
    <Id_History>a6728fa5-9162-4ba1-98e8-088bb9c16549,</Id_History>
    <Library_Id>be5273b1-d682-4361-99d9-6204f2d47eb7</Library_Id>
    <Title>Integer Overflow Attack</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology> Any</Technology>
    <Type>Attack</Type>
    <DirectLink>Integer Overflow Attack</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>2</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="Html">
    <Data><![CDATA[<br />
  <br />
  <h1>Applies To</h1>
  <p>Applications written in any language that does not perform automatic bounds checking.</p>
  <h1>Description</h1>
  <p>An integer overflow occurs when an integer is incremented over the maximum value that the data type can hold. The resulting value depends on the compiler in use. ISO C99 defines the result of an integer overflow to be the assigned value modulo one more than the maximum integer size. This is also known as wrapping around zero.</p>
  <p>Unlike buffer overflows, when an integer overflow occurs no memory other than that used by the integer is affected. However, it is easy for a programmer to assume that increasing the value of an integer will result in a larger integer. When the opposite happens unexpectedly, the program logic is altered. It is important to note that unless a check is added, the program has no way of knowing that the integer overflow happened and hence will continue with the assumption that the integer has the correct value. This is particularly a problem when a program is deciding how much memory to allocate for another variable. Common side effects are heap corruption causing the program to crash or a buffer overflow allowing arbitrary code execution.</p>
  <h1>Impact</h1>
  <ul>
    <li>Denial of Service: Erroneous and unexpected integer values from an overflow can cause the application to crash. </li>
    <li>Data Corruption: If the result is used in a file read or write operation the application may read or write from the wrong place in disk or memory, resulting in corruption. </li>
    <li>Remote Code Execution: Often remote code may be executed if the overflowed integer is used for memory management or indexing into a buffer. </li>
  </ul>
  <h1>Vulnerabilities</h1>
  <ul>
    <li>Improper arithmetic </li>
    <li>Failure to validate integer input </li>
    <li>Integer calculations or assignments used to determine the size of a buffer </li>
    <li>Insufficient bounds checking and failure to consider sign </li>
    <li>Program logic that makes assumptions about the value of integers</li>
  </ul>
  <h1>Countermeasures</h1>
  <ul>
    <li>
      <strong>Arithmetic checking: </strong>Always check that the value of adding two positive integers is greater than either operand. Take extra care when performing arithmetic operations with values near the maximum of the data type. </li>
    <li>
      <strong>Using a language or framework that does integer checking:</strong> Frameworks like .NET and java can be set to automatically check for integer overflows and underflows. (e.g., CheckForOverflowUnderflow in C#, RemoveIntegerChecks in VB.NET) </li>
    <li>
      <strong>Input Validation:</strong> Validate the untrusted input for upper and lower limits </li>
    <li>
      <strong>Verify Logic:</strong> Ensure that all integer logic will operate appropriately for the accepted limits, in all cases.</li>
  </ul>
  <h1>Example</h1>
  <p>The code segment below shows how a small increment can cause an integer overflow:</p>
  <pre>unsigned int x = 0xFFFFFFFF;unsigned int y = x + 1; // now y == 0x = 0xFFFFFFFF;y = x+2;// now y == 1</pre>
  <p>Adding 2 to the maximum value that the unsigned integer can hold will cause the y to wrap around to 1.</p>
  <h1>Additional Resources</h1>
  <ul>
    <li>For more information on Integer Overflows, see: <a href="https://www.owasp.org/index.php/Buffer_Overflows#Integer_Overflow">https://www.owasp.org/index.php/Buffer_Overflows#Integer_Overflow</a><br /></li>
    <li>For more information on How to Defend Against Deadly Integer Overflow Attacks, see: <a href="http://www.eweek.com/c/a/Application-Development/How-to-Defend-Against-Deadly-Integer-Overflow-Attacks/">http://www.eweek.com/c/a/Application-Development/How-to-Defend-Against-Deadly-Integer-Overflow-Attacks/</a></li>
    <li>
        For more information on Another Look at the SafeInt Class, see: <a href="http://msdn.microsoft.com/en-us/library/ms972819.aspx">http://msdn.microsoft.com/en-us/library/ms972819.aspx</a><br /></li>
  </ul>
  <h1>Related Items</h1>
  <ul>
    <li>
      <a href="/article/d190e4a5-6f18-409a-9c0d-a06156c47e6e">Attack: Integer Underflow Attack</a>
    </li>
    <li>
      <a href="/article/c392a633-2f74-4557-94ba-9fd6eeeefb95">Attack: Client-side Validation Attack</a>
    </li>
    <li>
      <a href="/article/946a5edb-e8f8-4365-8675-b8a5032c201b">Guideline: Validate All Data Passed Between Native and Java Code </a>
    </li>
    <li>
      <a href="/article/40eea61e-c8bd-494a-b75d-c18c2074c752">Guideline: Validate Input from All Sources </a>
    </li>
    <li>
      <a href="/article/6e981095-84bd-4158-a212-8f9937bcb336">Guideline: Do Not Rely on Client-Side Validation </a>
    </li>
    <li>
      <a href="/article/f29fac90-c626-41d6-9184-acd6007696cf">Guideline: Validate Input for Length, Range, Format, and Type </a>
    </li>
  </ul>]]></Data>
  </Content>
</TeamMentor_Article>