<?xml version="1.0"?>
<TeamMentor_Article Metadata_Hash="2075287915" Content_Hash="-122696765">
  <Metadata>
    <Id>8698cde2-0fdf-4676-a043-ae90e62f55b8</Id>
    <Id_History>4b11c55a-9205-4ed6-9add-14e6addfc5b3,</Id_History>
    <Library_Id>be5273b1-d682-4361-99d9-6204f2d47eb7</Library_Id>
    <Title>Command Injection Attack</Title>
    <Category>Input and Data Validation</Category>
    <Phase>Implementation</Phase>
    <Technology> Any</Technology>
    <Type>Attack</Type>
    <DirectLink>Command Injection Attack</DirectLink>
    <Tag />
    <Security_Demand />
    <Author />
    <Priority>1</Priority>
    <Status />
    <Source>SI</Source>
  </Metadata>
  <Content Sanitized="true" DataType="wikitext">
    <Data><![CDATA[=Applies To

All applications.
=Description

Command injection problems are a subset of injection problems in which the process is tricked into either executing code or calling external processes of the attacker's choice through the injection of control information into the data stream.
=Impact

    *Elevation of Privilege: Command injection can allow for the execution of arbitrary commands and code by the attacker.

=Vulnerabilities

    *Failure to Validate User Input: Situations where control information and data are mixed create opportunities for command injection.

=Countermeasures

    *Validate user input. Prevent commands from being included in data by validating input for type, length, range, and format. Whitelist acceptable input and reject everything else. Escape meta characters and be aware of canonicalization issues. Remember that data may be changed as it flows through the program, so validating at multiple stages is often appropriate.
    *Do not use input data in commands directly. Clever formatting may be used so that the user's input is treated as its own separate command instead of as data. Therefore, validate the input and explicitly type it as data so that it cannot be interpreted as a command even if it contains one.
    *Avoid using command interpreters. Although not always practical, using a well maintained API will have better results than invoking commands through an interpreter or external process.

=Example

The following code is wrapper around the UNIX command cat which prints the contents of a file to standard out. It is also injectable:

{{{
#include <stdio.h>#include <unistd.h>int main(int argc, char **argv) {  
char cat[] = "cat ";  char *command;  size_t commandLength;  commandLength = strlen(cat) + strlen(argv[1]) + 1;  
command = (char *) malloc(commandLength);  strncpy(command, cat, commandLength);  strncat(command, argv[1], (commandLength - strlen(cat)) ); 
system(command);  return (0);}
}}}

Used normally, the output is simply the contents of the file requested:

{{{
$ ./catWrapper Story.txtWhen last we left our heroes...
}}}

However, if we add a semicolon and another command to the end of this line, the command is executed by catWrapper with no complaint:

{{{
$ ./catWrapper Story.txt; lsWhen last we left our heroes...Story.txt 
doubFree.c nullpointer.cunstosig.c www* a.out*format.c strlen.c useFree*catWrapper* misnull.c strlength.c 
useFree.c commandinjection.c nodefault.c trunc.c writeWhatWhere.c
}}}

If catWrapper had been set to have a higher privilege level than the standard user or could be executed anonymously, arbitrary commands could be executed with that higher privilege.

Another example of this type of behavior can be seen with XSL, the style sheet language for XML. The primary purpose of XSL is to provide an easy and modular way to transform XML documents into other XML documents such as HTML. In particular, different XSL styles can be attached to the same XML and are sometimes supplied by the user. Microsoft extended the functionality of XSL to allow scripting code to be embedded in the style sheets with the <msxsl:script> tag. If an attacker has the ability to modify or replace the XSL style sheet in use, they can therefore inject any command to the system running the application simply by including it in the style sheet.

In many programming languages there is an eval() function that, as the name suggests, evaluates a string as an expression. Among the members of this list are the commonly used JavaScript, ASP, Python, Perl, Ruby, and PHP. Blurring the distinction between data and code presents a huge security risk; this case is no different. User input is sometimes used in eval() expressions allowing arbitrary code to be executed. Consider an example where eval() is used in a php application to join strings:

{{{
$name; // ask the user for their name and store it here$str = '$user stole my coffee!';
$str_after_eval = eval("$str;");echo $str. "\n";echo $str_after_eval. "\n";
}}}

If the user enters the name "Alice", this code will output the following:

{{{
$user stole my coffee!Alice stole my coffee!
}}}

However, if the user enters the name {{{"echo exec('whoami'); echo"}}} then the application will return the name of the system user running the php/html application. Any system command or external program in the path could be run in this fashion.

=Additional Resources

    *For more information on the Javascript Eval function, see: http://en.wikipedia.org/wiki/Eval.
    *For more information on script blocks in XSL, see: Script Blocks Using msxsl:script
    *For more information on XSL transformations, see: XSL Transformations

=Related Items

    *[[00d296c8-2c75-47ef-a659-5b4f25d5c73f|Attack: Canonicalization Attack]]
    *[[9d60faca-687b-4c69-91ba-f5712af0fd02|Attack: Server-Side Code Injection Attack]]
    *[[b1757bda-0a0d-48e7-b101-3c4088e41878|Attack: SQL Injection Attack]]
    *[[ae392dbb-fdb4-443f-9d17-78240b4acc95|Attack: XML Injection Attack]]
    *[[1508d763-03f1-4b43-bf8e-ad7cf8edebd7|Attack: Xpath-XQuery Attack]]
    *[[1408d3c3-7fc1-4ff0-910e-cdf0e191b669|Attack: Client-side Validation Attack]]
    *[[36ce61ac-adcc-45a9-9910-95d477142c8b|Attack: Cross Site Scripting Attack]]
    *[[e4a899ec-9301-4751-ae07-69a265336d8b|Attack: AJAX Injection Attack]]
    *[[61f0d74e-d9b6-4e27-9e12-da65baff83fd|Attack: LDAP Injection Attack]]
    *[[41ff6525-2cae-40a5-91e9-365d2d26feb9|Attack: Man in the Middle Attack]]
    *Guideline: Do Not Rely on Request Validation
    *Guideline: Validate All Data Passed Between Native and Java Code
    *Guideline: Filter All User-Supplied Filename and Path Input
    *Guideline: Validate Input from All Sources
    *Guideline: Validate Input for Length, Range, Format, and Type
    *Guideline: Do Not Rely on Client-Side Validation

]]></Data>
  </Content>
</TeamMentor_Article>